# pglcmd.lib - shell functions for pglcmd
#
# Copyright (C) 2005 - 2010 jre <jre-phoenix@users.sourceforge.net>
# Parts and ideas from JFM, /meth/usr, lestlest (clessing), Morpheus and
# perhaps others. More Info: http://forums.phoenixlabs.org
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# Following is a modified version of /lib/lsb/init-functions (Debian 3.2-23). If
# that file exists on your system, then the functions in that file will
# overwrite the following functions.
################################################################################
# /lib/lsb/init-functions for Debian -*- shell-script -*-
#
#Copyright (c) 2002-08 Chris Lawrence
#All rights reserved.
#
#Redistribution and use in source and binary forms, with or without
#modification, are permitted provided that the following conditions
#are met:
#1. Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
#2. Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in the
#   documentation and/or other materials provided with the distribution.
#3. Neither the name of the author nor the names of other contributors
#   may be used to endorse or promote products derived from this software
#   without specific prior written permission.
#
#THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
#IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
#WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
#LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
#BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
#OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
#EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# start_daemon [-f] [-n nicelevel] [-p pidfile] pathname [args...]
#     runs the specified program as a daemon. The start_daemon function shall
# check if the program is already running using the algorithm given above. If
# so, it shall not start another copy of the daemon unless the -f option is
# given. The -n option specifies a nice level. See nice. start_daemon shall
# return the LSB defined exit status codes. It shall return 0 if the program has
# been successfully started or is running and not 0 otherwise.

start_daemon () {
    local force nice pidfile exec i specified
    force=0
    nice=0
    pidfile=/dev/null
    specified=0

    OPTIND=1
    while getopts fn:p: opt ; do
        case "$opt" in
            f)  force=1;;
            n)  nice="$OPTARG";;
            # Prevent overwriting "-p pidfile" with "-p guarding.p2p"
            p)  [ ! "$specified" = 1 ] && pidfile="$OPTARG" && specified=1;;
        esac
    done

    shift $(($OPTIND - 1))
    if [ "$1" = '--' ]; then
        shift
    fi
    exec="$1"; shift

    if [ $force = 1 ]; then
        exec $exec $@ &
        # If renice fails somehow just ignore it.
        if test_external renice ; then
            PID="$(pidofproc $PID_OPT $exec)" || {
                sleep 1
                PID="$(pidofproc $exec)"
            } &&
            renice -n "$nice" -p "$PID" >/dev/null 2>&1
        fi
    elif [ $pidfile ]; then
        # If daemon is already running, return 0.
        pidofproc -p $pidfile $exec >/dev/null 2>&1 && return 0
        exec $exec $@ &
        # If renice fails somehow just ignore it.
        if test_external renice ; then
            PID="$(pidofproc -p $pidfile $exec)" || {
                sleep 1
                PID="$(pidofproc -p $pidfile $exec)"
            } &&
            renice -n "$nice" -p "$PID" >/dev/null 2>&1
        fi
    else
        # If daemon is already running, return 0.
        pidofproc $exec >/dev/null 2>&1 && return 0
        exec $exec $@ &
        # If renice fails somehow just ignore it.
        if test_external renice ; then
            PID="$(pidofproc $exec)" || {
                sleep 1
                PID="$(pidofproc $exec)"
            } &&
            renice -n "$nice" -p "$PID" >/dev/null 2>&1
        fi
    fi
}

# pidofproc [-p pidfile] pathname
#     The pidofproc function shall return one or more process identifiers for a
# particular daemon using the algorithm given above. Only process identifiers of
# running processes should be returned. Multiple process identifiers shall be
# separated by a single space.
#     Note: A process may exit between pidofproc discovering its identity
# and the caller of pidofproc being able to act on that identity. As a result,
# no test assertion can be made that the process identifiers returned by
# pidofproc shall be running processes.
#     The pidofproc function shall return the LSB defined exit status codes for
# "status". It shall return 0 if the program is running and not 0 otherwise.
pidofproc () {
    local pidfile line i pids= status specified pid
    pidfile=
    specified=

    OPTIND=1
    while getopts p: opt ; do
        case "$opt" in
            p)  pidfile="$OPTARG"; specified=1;;
        esac
    done
    shift $(($OPTIND - 1))

    base="$(basename $1)"
    if [ ! "$specified" ]; then
        pidfile="/var/run/$base.pid"
    fi

    if [ -n "${pidfile:-}" ] && [ -r "$pidfile" ]; then
        read pid < "$pidfile"
        if [ -n "${pid:-}" ]; then
            if $(kill -0 "${pid:-}" 2> /dev/null); then
                echo "$pid"
                return 0
            elif ps "${pid:-}" >/dev/null 2>&1; then
                echo "$pid"
                return 0 # program is running, but not owned by this user
            else
                return 1 # program is dead and /var/run pid file exists
            fi
        fi
    fi
    if test_external pidof && [ ! "$specified" ]; then
        status="0"
        pidof -o %PPID -x $1 || status="$?"
        # According to http://forums.phoenixlabs.org/showpost.php?p=128365&postcount=18
        # the Synology busybox pidof doesn't recognize the -o and -x options. Then you may take this,
        # but this doesn't work for the watchdog.
        #pidof $1 || status="$?"
        if [ "$status" = 1 ]; then
            return 3 # program is not running
        fi
        return 0
    fi
    if [ "$specified" ]; then
        return 3 # program does not appear to be running after trying PID file
    fi

#     # TODO: add this!?
#     if [ -x "$1" ] ; then
#         return 3    # daemon is installed, so it is known. But the pidfile
#                     # (/var/run/$base.pid) is not existing/empty. So assume
#                     # daemon is not running.
#     fi

    return 4 # Unable to determine status
}

# killproc [-p pidfile] pathname [signal]
#     The killproc function shall stop the specified program. The program is
# found using the algorith?m given above. If a signal is specified, using the
# -signal_name or -signal_number syntaxes as specified by the kill command, the
# program is sent that signal. Otherwise, a SIGTERM followed by a SIGKILL after
# an unspecified number of seconds shall be sent. If a program has been
# terminated, the pidfile should be removed if the terminated process has not
# already done so. The killproc function shall return the LSB defined exit
# status codes. If called without a signal, it shall return 0 if the program has
# been stopped or is not running and not 0 otherwise. If a signal is given, it
# shall return 0 only if the program is running.

killproc () {
    local pidfile sig status base i name_param is_term_sig
    pidfile=
    name_param=
    is_term_sig=no

    OPTIND=1
    while getopts p: opt ; do
        case "$opt" in
            p)  pidfile="$OPTARG";;
        esac
    done
    shift $(($OPTIND - 1))

    base="$(basename $1)"
    if [ ! $pidfile ]; then
        pidfile="/var/run/$base.pid"
    fi

    # Remove leading - and SIG from the sig. If none is given ($2), sig stays empty. (probably!?)
    sig=$(echo ${2:-} | sed -e 's/^-\(.*\)/\1/')
    sig=$(echo $sig | sed -e 's/^SIG\(.*\)/\1/')
    if [ -z "$sig" ] || [ "$sig" = 15 ] || [ "$sig" = TERM ]; then
        is_term_sig=yes
    fi
    status=0
    if [ ! "$is_term_sig" = yes ]; then
        if [ -n "$sig" ]; then
            #/sbin/start-stop-daemon --stop --signal "$sig" --quiet $name_param || status="$?"
            PID="$(pidofproc $1)" &&
            kill -s $sig $PID ||
            status="$?"
        else
            # TODO: unnecessary, "if [ -n "$sig" ]" is always true above, because
            # if -z "$sig" then is_term_sig=yes
            #/sbin/start-stop-daemon --stop --quiet $name_param || status="$?"
            PID="$(pidofproc $1)" &&
            kill $PID ||
            status="$?"
        fi
    else
        #/sbin/start-stop-daemon --stop --quiet --oknodo $name_param || status="$?"
        # send TERM signal
        PID="$(pidofproc $1)" &&
        kill $PID ||
        status="$?"
    fi
    if [ ! "$is_term_sig" = yes ] && [ ! "$status" = 0 ]; then
        return $status
    fi

    if [ "$status" = 0 ] && [ "$is_term_sig" = yes ] && [ "$pidfile" ]; then
        # Bug, if the pidofproc succeeds, then process is still running. Then
        # don't return 0!
        pidofproc -p "$pidfile" "$1" >/dev/null || rm -f "$pidfile"
    fi
    return 0
}

# Return LSB status
status_of_proc () {
    local pidfile daemon name status

    pidfile=
    OPTIND=1
    while getopts p: opt ; do
        case "$opt" in
            p)  pidfile="$OPTARG";;
        esac
    done
    shift $(($OPTIND - 1))

    if [ -n "$pidfile" ]; then
        pidfile="-p $pidfile"
    fi
    daemon="$1"
    name="$2"

    status="0"
    pidofproc $pidfile $daemon >/dev/null || status="$?"
    if [ "$status" = 0 ]; then
        log_success_msg "$name is running"
        return 0
    elif [ "$status" = 4 ]; then
        log_failure_msg "could not access PID file for $name"
        return $status
    else
        log_failure_msg "$name is not running"
        return $status
    fi
}

log_success_msg () {
    if [ -n "${1:-}" ]; then
        log_begin_msg $@
    fi
    log_end_msg 0
}

log_failure_msg () {
    if [ -n "${1:-}" ]; then
        log_begin_msg $@ "..."
    fi
    log_end_msg 1 || true
}

log_warning_msg () {
    if [ -n "${1:-}" ]; then
        log_begin_msg $@ "..."
    fi
    log_end_msg 255 || true
}

#
# NON-LSB HELPER FUNCTIONS
#
# int get_lsb_header_val (char *scriptpathname, char *key)
get_lsb_header_val () {
        if [ ! -f "$1" ] || [ -z "${2:-}" ]; then
                return 1
        fi
        LSB_S="### BEGIN INIT INFO"
        LSB_E="### END INIT INFO"
        sed -n "/$LSB_S/,/$LSB_E/ s/# $2: \(.*\)/\1/p" $1
}

# int log_begin_message (char *message)
log_begin_msg () {
    if [ -z "${1:-}" ]; then
        return 1
    fi
    echo -n "$@"
}

# Sample usage:
# log_daemon_msg "Starting GNOME Login Manager" "gdm"
#
# On Debian, would output "Starting GNOME Login Manager: gdm"
# On Ubuntu, would output " * Starting GNOME Login Manager..."
#
# If the second argument is omitted, logging suitable for use with
# log_progress_msg() is used:
#
# log_daemon_msg "Starting remote filesystem services"
#
# On Debian, would output "Starting remote filesystem services:"
# On Ubuntu, would output " * Starting remote filesystem services..."

log_daemon_msg () {
    if [ -z "${1:-}" ]; then
        return 1
    fi

    if [ -z "${2:-}" ]; then
        echo -n "$1:"
        return
    fi

    echo -n "$1: $2"
}

# #319739
#
# Per policy docs:
#
#     log_daemon_msg "Starting remote file system services"
#     log_progress_msg "nfsd"; start-stop-daemon --start --quiet nfsd
#     log_progress_msg "mountd"; start-stop-daemon --start --quiet mountd
#     log_progress_msg "ugidd"; start-stop-daemon --start --quiet ugidd
#     log_end_msg 0
#
# You could also do something fancy with log_end_msg here based on the
# return values of start-stop-daemon; this is left as an exercise for
# the reader...
#
# On Ubuntu, one would expect log_progress_msg to be a no-op.
log_progress_msg () {
    if [ -z "${1:-}" ]; then
        return 1
    fi
    echo -n " $@"
}

# int log_end_message (int exitstatus)
log_end_msg () {
    # If no arguments were passed, return
    if [ -z "${1:-}" ]; then
        return 1
    fi

    retval=$1

    if [ $1 -eq 0 ]; then
        echo "."
    elif [ $1 -eq 255 ]; then
        echo " (warning)."
    else
        echo " failed!"
    fi
    return $retval
}

# End of modified Debian /lib/lsb/init-functions.
################################################################################

# Function to test if an external application exists.
# Usage: test_external basename_of_the_application
# Returns 0 if base is installed and executable in PATH
# Otherwise returns E_XEXTERNAL
# NOTE: "which" should not be used, because it is not available on all systems,
# e.g. routers.
test_external () {
    IFS=":"
    for PATH_I in $PATH ; do
        [ -x "$PATH_I"/"$1" ] && IFS=$STDIFS && return 0
    done
    IFS=$STDIFS
    log_failure_msg "Error $E_XEXTERNAL: $1 not installed."
    return $E_XEXTERNAL
}

test_INIT () {
    case "$INIT" in
        '0'|'1')
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the INIT setting."
            exit $E_CONFIG
            ;;
    esac
}

test_CRON () {
    case "$CRON" in
        '0'|'1')
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the CRON setting."
            exit $E_CONFIG
            ;;
    esac
}

test_VERBOSITY () {
    case "$VERBOSITY" in
        '0'|'1'|'2')
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the VERBOSITY setting."
            exit $E_CONFIG
            ;;
    esac
}

test_DAEMON () {
    [ -x "$DAEMON" ] || {
            log_failure_msg "Error $E_XBIN: $DAEMON not installed."
            log_failure_msg "Could not detect $DESC daemon $NAME."
            log_failure_msg "Install it in PATH ($PATH) or specify DAEMON in $CMD_CONF."
            exit $E_XBIN
    }
}

test_CMD_PATHNAME () {
    [ -x "$CMD_PATHNAME" ] || {
        log_failure_msg "$0: $CMD_PATHNAME not installed."
        exit $E_XBIN
    }
}

test_LOG_SYSLOG () {
    case "$LOG_SYSLOG" in
        '0'|'1')
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the LOG_SYSLOG setting."
            exit $E_CONFIG
            ;;
    esac
}

test_IPTABLES_TARGET () {
    case "$IPTABLES_TARGET" in
        'NFQUEUE')
            [ "$NFQUEUE_NUMBER" -ge 0 ] && [ "$NFQUEUE_NUMBER" -le 65535 ] || {
                log_failure_msg "Error $E_CONFIG: Check the NFQUEUE_NUMBER setting."
                exit $E_CONFIG
                }
            ;;
        # although QUEUE is deprecated, it is the same as NFQUEUE 0.
        'QUEUE')
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the IPTABLES_TARGET setting."
            exit $E_CONFIG
            ;;
    esac
}

test_REJECT () {
    case "$REJECT" in
        '0')
            true
            ;;
        '1')
            # No test for REJECT_MARK, yet
            # No test for REJECT_IN. Valid: all iptables targets
            # No test for REJECT_OUT. Valid: all iptables targets
            # No test for REJECT_FWD. Valid: all iptables targets
            # Transition REJECT_FW REJECT_FWD.
            # If old var is not-empty, but new var is empty, then take old value.
            [ -z "$REJECT_FW" ] || {
                REJECT_FWD=${REJECT_FWD:-${REJECT_FWD}}
                log_warning_msg "REJECT_FW is deprecated. Use REJECT_FWD instead."
                }
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the REJECT setting."
            exit $E_CONFIG
            ;;
    esac
}

test_ACCEPT () {
    case "$ACCEPT" in
        '0')
            true
            ;;
        '1')
            # No test for ACCEPT_MARK, yet
            true
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the ACCEPT setting."
            exit $E_CONFIG
            ;;
    esac
}

test_BLOCKLISTS_DIR () {
    [ -d "$BLOCKLISTS_DIR" ] || {
        echo -n "Creating missing directory $BLOCKLISTS_DIR ..."
        mkdir -p $BLOCKLISTS_DIR && echo "."
    } || {
        log_failure_msg "Error $E_XCD: Missing directory $BLOCKLISTS_DIR."
        log_failure_msg "Check the BLOCKLISTS_DIR setting."
        exit $E_XCD
    }
}

test_CMD_LOG () {
    [ -d "$(dirname $CMD_LOG)" ] || {
        echo -n "Creating missing directory $(dirname $CMD_LOG) ..."
        mkdir -p "$(dirname $CMD_LOG)" && echo "."
    } || {
        log_failure_msg "Error $E_XCD: Missing directory $(dirname $CMD_LOG)."
        log_failure_msg "Check the CMD_LOG setting."
        exit $E_XCD
    }
}

test_PIDFILE () {
    [ -d "$(dirname $PIDFILE)" ] || {
        log_failure_msg "Error $E_XCD: Missing directory $(dirname $PIDFILE)."
        log_failure_msg "$NAME needs a directory to write its pidfile to!"
        log_failure_msg "Check the PIDFILE setting."
        exit $E_XCD
    }
}

test_WD_PID () {
    [ -d "$(dirname $WD_PID)" ] || {
        log_failure_msg "Error $E_XCD: Missing directory $(dirname $WD_PID)."
        log_failure_msg "$(basename $WD_PATHNAME) needs a directory to write its pidfile to!"
        log_failure_msg "Check the WD_PID setting."
        exit $E_XCD
    }
}

test_WD_PATHNAME () {
    [ -x "$WD_PATHNAME" ] || {
        log_failure_msg "Error $E_CONFIG: Check the WD_PATHNAME setting."
        log_failure_msg "Not starting $(basename $WD_PATHNAME)."
        exit $E_CONFIG
        }
}

test_IPTABLES_VARS () {
    case "$IPTABLES_SETTINGS" in
        '0')
            true
            ;;
        '1')
            case "$IPTABLES_ACTIVATION" in
                '0'|'1'|'2')
                    true
                    ;;
                *)
                    log_failure_msg "Error $E_CONFIG: Check the IPTABLES_ACTIVATION setting."
                    exit $E_CONFIG
                    ;;
            esac
            case "$WHITE_LOCAL" in
                '0'|'1'|'2')
                    true
                    ;;
                *)
                    log_failure_msg "Error $E_CONFIG: Check the WHITE_LOCAL setting."
                    exit $E_CONFIG
                    ;;
            esac
            # No test for WHITE_TCP_IN. Valid: port number or associated service name
            # No test for WHITE_UDP_IN.
            # No test for WHITE_TCP_OUT.
            # No test for WHITE_UDP_OUT.
            # No test for WHITE_TCP_FWD.
            # Transition WHITE_TCP_FORWARD WHITE_TCP_FWD.
            # If old var is not-empty, but new var is empty, then take old value.
            [ -z "$WHITE_TCP_FORWARD" ] || {
                WHITE_TCP_FWD=${WHITE_TCP_FWD:-${WHITE_TCP_FORWARD}}
                log_warning_msg "WHITE_TCP_FORWARD is deprecated. Use WHITE_TCP_FWD instead."
                }
            # No test for WHITE_UDP_FWD.
            # Transition WHITE_UDP_FORWARD WHITE_UDP_FWD.
            # If old var is not-empty, but new var is empty, then take old value.
            [ -z "$WHITE_UDP_FORWARD" ] || {
                WHITE_UDP_FWD=${WHITE_UDP_FWD:-${WHITE_UDP_FORWARD}}
                log_warning_msg "WHITE_UDP_FORWARD is deprecated. Use WHITE_UDP_FWD instead."
                }
            # No test for WHITE_IP_IN. Valid: network name, a hostname (please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea), a network IP address (with /mask), or a plain IP address.
            # No test for WHITE_IP_OUT.
            # No test for WHITE_IP_FWD.
            # Transition WHITE_IP_FORWARD WHITE_IP_FWD.
            # If old var is not-empty, but new var is empty, then take old value.
            [ -z "$WHITE_IP_FORWARD" ] || {
                WHITE_IP_FWD=${WHITE_IP_FWD:-${WHITE_IP_FORWARD}}
                log_warning_msg "WHITE_IP_FORWARD is deprecated. Use WHITE_IP_FWD instead."
                }

            # No test for INTERFACES.
            # No test for IP_REMOVE. Valid: all regular expressions for grep
            ;;
        '2')
            [ -d "$IPTABLES_CUSTOM_DIR" ] || {
                log_failure_msg "Error $E_XCD: Could not find $IPTABLES_CUSTOM_DIR."
                log_failure_msg "Check the IPTABLES_CUSTOM_DIR setting."
                exit $E_XCD
            }
            ;;
        *)
            log_failure_msg "Error $E_CONFIG: Check the IPTABLES_SETTINGS setting."
            exit $E_CONFIG
            ;;
    esac
}

# Test if user is root
test_root () {
    case "$(id -ru)" in
        '0')
            true
            ;;
        *)
            log_failure_msg "Error $E_NOTROOT: This program must be run as root."
            exit $E_NOTROOT
            ;;
    esac
}

################################################################################
# Functions

# Function to test if there is an internet connection (currently: if testhost is reachable)
test_net () {
    test_external wget || exit $E_XEXTERNAL
    $WGET_OPTS -Q 1 -O /dev/null $TESTHOST    # Don't quote WGET_OPTS!
    if [ "$?" -ne 0 ] ; then
        log_failure_msg "Error $E_NETWORK_DOWN: No connection to $TESTHOST. Aborting!"
        exit $E_NETWORK_DOWN
    fi
}

white_local () {
    # If CHAINS is empty/not set, then set it to "all". Replace all with the single names.
    CHAINS=${CHAINS:-all}
    [ "$CHAINS" != all ] || CHAINS="INPUT OUTPUT FORWARD"

    if [ "$WHITE_LOCAL" -ne 0 ] ; then
        # Whitelist loopback interface
        # TODO: Only do this if checking the loopback interface is enabled
        # (although otherwise just no traffic will ever get to the pgl_ chain were this rule is placed).
        # Do this only once on (re)start
        if [ "$1" = start ] || [ "$1" = restart ] ; then
            for CHAIN in $CHAINS ; do
                case $CHAIN in
                INPUT)
                    PGL_CHAIN="$IPTABLES_IN"
                    CMD_LOOP="-i lo"
                    ;;
                OUTPUT)
                    PGL_CHAIN="$IPTABLES_OUT"
                    CMD_LOOP="-o lo"
                    ;;
                FORWARD)
                    continue
                    ;;
                *)
                    echo "Unknown CHAIN $CHAIN specified."
                    exit 1
                    ;;
                esac
                echo -n "  Allowing loopback traffic in $CHAIN"
                # Insert whitelisting rules for whole loopback interface
                iptables -I $PGL_CHAIN $CMD_LOOP -j $IPTABLES_TARGET_WHITELISTING
                RETVAL=$?
                log_end_msg $RETVAL
                [ "$RETVAL" = 0 ] || exit $E_IPTABLES
            done
        fi

        # Whitelist the DNS server(s).
        # For this /etc/resolv.conf and the output of "iptables -L -nv" is scanned for certain patterns.
        if [ -f /etc/resolv.conf ] ; then
            # Get the DNS server's IP
            DNS_IPS="$( grep nameserver /etc/resolv.conf | grep -Eo "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" )"

            # Insert whitelisting rules for DNS server.
            for CHAIN in $CHAINS ; do
                case $CHAIN in
                INPUT)
                    continue
                    ;;
                OUTPUT)
                    PGL_CHAIN="$IPTABLES_OUT"
                    ;;
                FORWARD)
                    PGL_CHAIN="$IPTABLES_FWD"
                    ;;
                esac

                for IP in $DNS_IPS ; do
                    echo -n "  Allowing $CHAIN traffic to DNS server $IP"
                    # Whitelist DNS server, if we do an inital start/restart (quick
                    # test of $1) or if the DNS server is not already whitelisted
                    # (time-consuming test of iptables output).
                    # With other words:
                    # pglcmd start/restart: always whitelist DNS server
                    # if-up: first check if DNS server is already whitelisted.
                    if [ "$1" = start ] || [ "$1" = restart ] ||
                    ! iptables -nv -L $PGL_CHAIN | grep -F "$IP " | grep $IPTABLES_TARGET_WHITELISTING > /dev/null 2>&1 ; then
                        iptables -I $PGL_CHAIN --destination $IP -j $IPTABLES_TARGET_WHITELISTING
                        RETVAL=$?
                        log_end_msg $RETVAL
                        [ "$RETVAL" = 0 ] || exit $E_IPTABLES
                    else
                        echo ", already done."
                    fi
                done
            done
        fi
    fi

    if [ "$WHITE_LOCAL" -eq 1 ] ; then
        # Automatically whitelist LAN of all up interfaces
        # TODO: Only do this if checking the corresponding interface is enabled
        # For this the output of "ifconfig" and "iptables -L -nv" is scanned for certain patterns

        # Get IPs of interfaces that are up
        LOCAL_IPS="$(ifconfig | \
            grep -Eo "inet addr:[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" | \
            grep -Eo "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" )"
        for IP in $LOCAL_IPS ; do
            case $IP in
            127.*)
                # IP is a loopback IP. This was already done above.
                ;;
            *)
                # For all other IPs
                # Get the corresponding subnetmask
                # Use grep -F followed by a blank to match exactly a specific IP!
                SUBNETMASK="$(ifconfig | grep -F "inet addr:${IP} " | \
                    grep -Eo "Mask:[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" | \
                    grep -Eo "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" )"
                # Set the scope (IP/subnetmask) as it will be shown by iptables
                if [ "$SUBNETMASK" = 255.255.255.0 ] ; then
                    # Scope is X.X.X.0/24
                    SCOPE="$( echo $IP | grep -Eo "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\." )0/24"
                elif [ "$SUBNETMASK" = 255.255.0.0 ] ; then
                    # Scope is X.X.0.0/16
                    SCOPE="$( echo $IP | grep -Eo "[0-9]{1,3}\.[0-9]{1,3}\." )0.0/16"
                else
                    # TODO: Find a way to check for the real IP/SUBNETMASK pattern.
                    # With an empty SCOPE the last grep command will just fail, so
                    # the result is as if no whitelisting already occured.
                    # So if the network is brought up several times there will be multiple identical rules,
                    # but no real harm will be done.
                    SCOPE=""
                fi

                # Insert whitelisting rules for LAN with SUBNETMASK.
                for CHAIN in $CHAINS ; do
                    case $CHAIN in
                    INPUT)
                        PGL_CHAIN="$IPTABLES_IN"
                        CMD_WHITE_IP="--source ${IP}/${SUBNETMASK}"
                        ;;
                    OUTPUT)
                        PGL_CHAIN="$IPTABLES_OUT"
                        CMD_WHITE_IP="--destination ${IP}/${SUBNETMASK}"
                        ;;
                    FORWARD)
                        PGL_CHAIN="$IPTABLES_FWD"
                        CMD_WHITE_IP="--source ${IP}/${SUBNETMASK} --destination ${IP}/${SUBNETMASK}"
                        ;;
                    esac
                    echo -n "  Allowing $CHAIN LAN traffic for $IP with subnetmask $SUBNETMASK"
                    # Whitelist LAN, if we do an inital start/restart (quick
                    # test of $1) or if the LAN is not already whitelisted
                    # (time-consuming test of iptables output).
                    # With other words:
                    # pglcmd start/restart: always whitelist LAN
                    # if-up: first check iptables output if LAN is already whitelisted.
                    if [ "$1" = start ] || [ "$1" = restart ] ||
                    ! iptables -nv -L $PGL_CHAIN | grep $IPTABLES_TARGET_WHITELISTING | grep -F "$SCOPE" > /dev/null 2>&1 ; then
                        iptables -I $PGL_CHAIN $CMD_WHITE_IP -j $IPTABLES_TARGET_WHITELISTING
                        RETVAL=$?
                        log_end_msg $RETVAL
                        [ "$RETVAL" = 0 ] || exit $E_IPTABLES
                    else
                        echo ", already done."
                    fi
                done
                ;;
            esac
        done
    fi
}

# Function to insert whitelisting iptables rules for ports with the module multiport
# Usage: white_port_iptables
#        $CHAIN, $PROTO and $MULTIPORT have to be set.
white_port_iptables () {
    PORTS="$( echo $MULTIPORT | sed "s|\(.*\),$|\1|" )"
    iptables -I $CHAIN -p $PROTO -m multiport --ports $PORTS -j $IPTABLES_TARGET_WHITELISTING \
        || fail_insert_iptables
}

# Function to construct $MULTIPORT variable as iptables accepts it (ports
# separated by ",", max 15 ports, port ranges (port:port) count as 2 ports) and
# call white_port_iptables
# Usage: white_port_prepare CHAIN PROTO PORTS
white_port_prepare () {
    local CHAIN PROTO MULTIPORT
    CHAIN=$1
    PROTO=$2
    shift 2
    COUNT=0
    MULTIPORT=""
    for PORT in $@ ; do
        # Count all ports (max 15 allowed in multiport)
        COUNT=$(($COUNT+1))
        # Port ranges count as 2 ports
        echo $PORT | grep -qv ":" || COUNT=$(($COUNT+1))
        if [ "$COUNT" -lt 15 ] ; then
            # Just continue to add ports, while less than 15
            MULTIPORT="$PORT,$MULTIPORT"
        elif [ "$COUNT" -eq 15 ] ; then
            # Whitelist 15 ports
            MULTIPORT="$PORT,$MULTIPORT"
            white_port_iptables
            # and then continue with a clean new run
            MULTIPORT=""
            COUNT=0
        elif [ "$COUNT" -gt 15 ] ; then
            # This happens if the 15th port is a port range
            # So whitelist the first 14 ports
            white_port_iptables
            # And then continue with the port range
            MULTIPORT="$PORT"
            COUNT=2
        fi
    done
    [ -z "$MULTIPORT" ] || white_port_iptables
}

# Function to be executed if iptables insert command fails:
# removes all iptables rules again and aborts
fail_insert_iptables () {
    log_end_msg $?
    delete_iptables
    exit $E_IPTABLES
}

# Set REMOVE_SCRIPT needed by insert_iptables and delete_iptables
REMOVE_SCRIPT="$MASTER_BLOCKLIST_DIR/.${CMD_NAME}.iptables.remove.sh"

# Function that inserts the iptables rules
insert_iptables () {
    # test_IPTABLES_VARS # Already tested in do_start
    test_external iptables || exit $?
    if [ -f "$REMOVE_SCRIPT" ] ; then
        echo -n "Old iptables remove script $REMOVE_SCRIPT exists. Strange. Executing now and then removing it"
        sh $REMOVE_SCRIPT
        rm $REMOVE_SCRIPT
        log_end_msg $?
    fi
    case "$IPTABLES_SETTINGS" in
    '0')
        test_VERBOSITY
        if [ "$VERBOSITY" -eq 1 ] ; then
            log_warning_msg "$(basename $0) is configured not to insert iptables rules."
        fi
        ;;
    # Place iptables rules in separate iptables chains (pgl_in, pgl_out and pgl_fwd).
    '1')
        echo "Inserting iptables ..."

        # Variable tests
        test_IPTABLES_TARGET
        test_REJECT
        test_ACCEPT

        # Set constant variables for iptables commands
        case "$IPTABLES_TARGET" in
        NFQUEUE)
            IPTABLES_TARGET_BLOCK="$IPTABLES_TARGET --queue-num $NFQUEUE_NUMBER"
            ;;
        QUEUE)
            IPTABLES_TARGET_BLOCK="$IPTABLES_TARGET"
            ;;
        esac

        # If CHAINS is empty/not set, then set it to "all". Replace all with the single names.
        CHAINS=${CHAINS:-all}
        [ "$CHAINS" != all ] || CHAINS="INPUT OUTPUT FORWARD"

        # Prepare and issue iptables commands for every chain.
        for CHAIN in $CHAINS ; do
            echo "  Setting up iptables for chain $CHAIN:"
            case $CHAIN in
            INPUT)
                PGL_CHAIN="$IPTABLES_IN"
                WHITE_TCP="$WHITE_TCP_IN"
                WHITE_UDP="$WHITE_UDP_IN"
                CMD_WHITE_IP="--source"
                WHITE_IP="$WHITE_IP_IN"
                CMD_ALLOW="--src-range"
                ALLOW_FILE="$ALLOW_IN"
                REJECT_TARGET="$REJECT_IN"
                ;;
            OUTPUT)
                PGL_CHAIN="$IPTABLES_OUT"
                WHITE_TCP="$WHITE_TCP_OUT"
                WHITE_UDP="$WHITE_UDP_OUT"
                CMD_WHITE_IP="--destination"
                WHITE_IP="$WHITE_IP_OUT"
                CMD_ALLOW="--dst-range"
                ALLOW_FILE="$ALLOW_OUT"
                REJECT_TARGET="$REJECT_OUT"
                ;;
            FORWARD)
                PGL_CHAIN="$IPTABLES_FWD"
                WHITE_TCP="$WHITE_TCP_FWD"
                WHITE_UDP="$WHITE_UDP_FWD"
                CMD_WHITE_IP="--source --destination"
                WHITE_IP="$WHITE_IP_FWD"
                CMD_ALLOW="--src-range --dst-range"
                ALLOW_FILE="$ALLOW_FWD"
                REJECT_TARGET="$REJECT_FWD"
                ;;
            *)
                echo "Unknown CHAIN $CHAIN specified."
                exit 1
                ;;
            esac

            # Create new pgl_ chain and remember iptables remove rules
            ( echo -n "    Creating chain" &&
                iptables -N $PGL_CHAIN &&
                echo "iptables -F $PGL_CHAIN" >> $REMOVE_SCRIPT &&
                echo "iptables -X $PGL_CHAIN" >> $REMOVE_SCRIPT ) ||
                fail_insert_iptables

            # Insert NFQUEUE rule.
            echo -n " and inserting NFQUEUE rule" &&
                iptables -I $PGL_CHAIN -j $IPTABLES_TARGET_BLOCK &&
                log_end_msg "$?" || fail_insert_iptables

            # Port Whitelisting
            ( [ -n "$WHITE_TCP" ] || [ -n "$WHITE_UDP" ] ) &&
                echo -n "    Whitelisting ports" &&
                white_port_prepare $PGL_CHAIN tcp $WHITE_TCP &&
                white_port_prepare $PGL_CHAIN udp $WHITE_UDP &&
                log_end_msg "$?"

            # IP Whitelisting
            [ -n "$WHITE_IP" ] && echo -n "    Whitelisting IPs" &&
                for IP in $WHITE_IP ; do
                    # Add whitelisting rule
                    # (add 2 rules in the FORWARD chain: once for --source, once for --destination)
                    for CMD in $CMD_WHITE_IP ; do
                        iptables -I $PGL_CHAIN $CMD $IP -j $IPTABLES_TARGET_WHITELISTING || fail_insert_iptables
                    done
                done &&
                log_end_msg "$?"

            # IP ranges whitelisting
            if [ -f "$ALLOW_FILE" ] ; then
                echo -n "    Whitelisting IP ranges"
                # Read the non-comment|not-empty lines from the allow file:
                ALLOW="$(grep -Ev "^[[:space:]]*#|^[[:space:]]*$" $ALLOW_FILE)"
                IFS=$'
' # Set IFS to newline only for LINE
                for LINE in $ALLOW ; do
                    IPRANGE_BEGIN="$(echo $LINE | grep -Eo "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" | head -n1)"
                    IPRANGE_END="$(echo $LINE | grep -Eo "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" | tail -n1)"
                    # Reset IFS for CMD
                    IFS=$STDIFS
                    for CMD in $CMD_ALLOW ; do
                        # Add whitelisting rule
                        # (add 2 rules in the FORWARD chain: once for --src-range, once for --dst-range)
                        iptables -I $PGL_CHAIN -m iprange $CMD $IPRANGE_BEGIN-$IPRANGE_END -j $IPTABLES_TARGET_WHITELISTING || {
                            # If iptables insertion failed assume that the line is malformed.
                            # Comment this line out.
                            sed -i "s|^$LINE$|# Malformed line commented out by $(basename $0): &|" $ALLOW_FILE
                            log_failure_msg "Commented out malformed line \"$LINE\" in $ALLOW_FILE."
                            }
                    done
                    IFS=$'
' # Set IFS to newline only again for the next LINE
                done
                # Reset IFS
                IFS=$STDIFS
                log_end_msg "$?"
            fi

            # Block "Marked block" packages: "Marked block" packages are sent back
            # to the head of the chain again (NF_REPEAT repeats the hook function)
            # by pgld. Block them at the head of the pglcmd_* chains.
            # Alternatively they could be blocked at the head of the
            # INPUT/OUTPUT/FORWARD chains, but I decided against that in order to
            # keep those chains cleaner. It has to be made sure that the MARK of the
            # packets is not changed by other iptables rules.
            if [ "$REJECT" -eq 1 ] ; then
                echo -n "    Inserting block rule"
                iptables -I $PGL_CHAIN -m mark --mark $REJECT_MARK -j $REJECT_TARGET || fail_insert_iptables
                # Log "Marked block" packages: The log-iptables-rules should be
                # placed directly before the block-iptables-rules (i.e. Insert them
                # directly after them)
                if [ -n "$LOG_IPTABLES" ] ; then    # string is not empty
                    echo -n " and log rule"
                    iptables -I $PGL_CHAIN -m mark --mark $REJECT_MARK -j $LOG_IPTABLES || fail_insert_iptables
                fi
                log_end_msg "$?"
            fi
        done

        # Automatically whitelist LAN of all up interfaces, loopback interface
        # and DNS server(s) (if configured)
        white_local

        # If custom iptables insertion scripts exist, execute them:
        CUSTOM_INSERT_SCRIPTS="$(find $IPTABLES_CUSTOM_DIR -maxdepth 1 -type f -name "*insert.sh" -print0 | xargs -0r)"
        [ -z "$CUSTOM_INSERT_SCRIPTS" ] || {
            for FILE in $CUSTOM_INSERT_SCRIPTS ; do
                echo -n "  Executing custom iptables insertion script $FILE"
                sh $FILE
                log_end_msg "$?"
            done
            }

        # Chain activation
        case "$IPTABLES_ACTIVATION" in
        '0')
            if [ "$VERBOSITY" -eq 1 ] ; then
                echo -n " - not activating the chains"
            fi
            ;;
        '1'|'2')
            case "$IPTABLES_ACTIVATION" in
            '1')
                CMD_STATE="-m state --state NEW"
                ;;
            '2')
                CMD_STATE=""
                ;;
            esac
            case "$ACCEPT" in
            '0')
                CMD_MARK_ACCEPT=""
                ;;
            '1')
                # Send all NEW packets, except the "marked accept" packets, to the pglcmd_* chains.
                # From there "marked" packets are sent back to the head of the chain again
                # (NF_REPEAT repeats the hook function). Thus "marked accept" packets traverse to
                # the rest of the iptables setup.
                # Problem: If another rule changes the MARK the packet will loop forever.
                CMD_MARK_ACCEPT="-m mark ! --mark $ACCEPT_MARK"
                ;;
            esac

            # If INTERFACES is empty/not set, then set it to "all".
            INTERFACES=${INTERFACES:-all}

            # Send traffic of the specified interfaces to the pgl chains.
            for INTERFACE in $INTERFACES ; do
                for CHAIN in $CHAINS ; do
                    case $CHAIN in
                    INPUT)
                        PGL_CHAIN="$IPTABLES_IN"
                        ;;
                    OUTPUT)
                        PGL_CHAIN="$IPTABLES_OUT"
                        ;;
                    FORWARD)
                        PGL_CHAIN="$IPTABLES_FWD"
                        ;;
                    esac

                    # Activate iptables chain and remember iptables remove rules
                    if [ "$INTERFACE" = all ] ; then
                        iptables -I $CHAIN $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN &&
                        echo "iptables -D $CHAIN $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN" >> ${REMOVE_SCRIPT}.tmp
                    else
                        case $CHAIN in
                        INPUT)
                            iptables -I $CHAIN -i $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN &&
                            echo "iptables -D $CHAIN -i $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN" >> ${REMOVE_SCRIPT}.tmp
                            ;;
                        OUTPUT)
                            iptables -I $CHAIN -o $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN &&
                            echo "iptables -D $CHAIN -o $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN" >> ${REMOVE_SCRIPT}.tmp
                            ;;
                        FORWARD)
                            iptables -I $CHAIN -i $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN &&
                            echo "iptables -D $CHAIN -i $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN" >> ${REMOVE_SCRIPT}.tmp &&
                            iptables -I $CHAIN -o $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN &&
                            echo "iptables -D $CHAIN -o $INTERFACE $CMD_STATE $CMD_MARK_ACCEPT -j $PGL_CHAIN" >> ${REMOVE_SCRIPT}.tmp
                            ;;
                        # Valid CHAINs was already tested above. No test needed here.
                        esac
                    fi
                    RET=$?
                    [ "$RET" -eq 0 ] || break 2
                done
            done
            # Try to build the REMOVE_SCRIPT in any way
            cat $REMOVE_SCRIPT >> ${REMOVE_SCRIPT}.tmp &&
            mv ${REMOVE_SCRIPT}.tmp $REMOVE_SCRIPT
            # If anything went wrong (then we broke out of the loops), do the
            # fail_insert_iptables with the REMOVE_SCRIPT as it is.
            [ "$RET" -eq 0 ] || fail_insert_iptables
            ;;
        esac
        log_end_msg 0    # Complete iptables insertion went well.
        ;;
    '2')
        CUSTOM_INSERT_SCRIPTS="$(find $IPTABLES_CUSTOM_DIR -maxdepth 1 -type f -name "*insert.sh" -print0 | xargs -0r)"
        [ -z "$CUSTOM_INSERT_SCRIPTS" ] || {
            for FILE in $CUSTOM_INSERT_SCRIPTS ; do
                echo -n "Executing custom iptables insertion script $FILE ..."
                sh $FILE && log_end_msg $? || fail_insert_iptables
                log_end_msg $?
            done
            }
        ;;
    esac
}

# Function that deletes the iptables rules
# iptables command errors are ignored, because removing an already removed rule
# causes an error, although this is no problem for us.
delete_iptables () {
    test_IPTABLES_VARS
    test_external iptables || exit $?
    echo "Deleting iptables ..."

    # Execute custom iptables remove scripts if configured
    if [ "$IPTABLES_SETTINGS" -gt 0 ] ; then
        # If custom iptables remove scripts exist, execute them:
        CUSTOM_REMOVE_SCRIPTS="$(find $IPTABLES_CUSTOM_DIR -maxdepth 1 -type f -name "*remove.sh" -print0 | xargs -0r)"
        [ -z "$CUSTOM_REMOVE_SCRIPTS" ] || {
            for FILE in $CUSTOM_REMOVE_SCRIPTS ; do
                echo -n "  Executing custom iptables remove script $FILE"
                sh $FILE
                log_end_msg $?
            done
            }
    fi
    # Delete previously inserted iptables rules in any case. REMOVE_SCRIPT is created in insert_iptables
    if [ -f "$REMOVE_SCRIPT" ] ; then
        echo "  Executing iptables remove script $REMOVE_SCRIPT"
        echo -n "  and then removing it"
        sh $REMOVE_SCRIPT
        rm $REMOVE_SCRIPT
        log_end_msg $?
    fi
    log_end_msg $?
}

set_md5sum () {
    SUM="$( echo $IP_REMOVE ; [ -f "$BLOCKLISTS_LIST" ] && md5sum $BLOCKLISTS_LIST ; [ -f "$MASTER_BLOCKLIST" ] && md5sum $MASTER_BLOCKLIST )"
    MD5SUM="$(echo $SUM | md5sum | cut -c -32)"
}

# All blocklists in the MASTER_BLOCKLIST_DIR directory, except those which end in "~", are used by pgld.
# Place "quotes" around every list. So spaces in listnames are allowed.
set_MASTER_BLOCKLISTS () {
    MASTER_BLOCKLISTS="$(find $MASTER_BLOCKLIST_DIR -maxdepth 1 -type f ! -name "*~" ! -name ".*" | sed -e 's|.*|\"&\"|' | tr "\n" " ")"
    [ -n "$MASTER_BLOCKLISTS" ] || {
        log_failure_msg "Error $E_BLOCKLIST: No master blocklist found in $MASTER_BLOCKLIST_DIR."
        exit $E_BLOCKLIST
        }
}

# Function that starts the watchdog
do_start_wd () {
    # Start pglcmd.wd.
    echo -n "Starting $(basename $WD_PATHNAME) ..."
    test_WD_PATHNAME
    test_WD_PID

    # Test WD_NICE setting.
    [ "$WD_NICE" -ge -20 ] && [ "$WD_NICE" -le 19 ] || {
        log_failure_msg "Error $E_CONFIG: Check the WD_NICE setting."
        exit $E_CONFIG
        }

    # Start pglcmd.wd in the background. Therefore no real check possible if this succeeded.
    if test_external start-stop-daemon > /dev/null 2>&1 ; then
        # Use start-stop-daemon
        # Start watchdog in the background with "-b"
        # Note: use -N for nice level, not -n as per LSB
        #start-stop-daemon -b -N $WD_NICE -p $WD_PID --exec $WD_PATHNAME --start --
        # Use -x and -S to avoid problems on synology
        start-stop-daemon -b -N $WD_NICE -p $WD_PID -x $WD_PATHNAME -S --
    else
        # LSB, start pglcmd.wd in the background with "&".
        start_daemon -n $WD_NICE -p $WD_PID $WD_PATHNAME &
    fi
    # TODO: kill -0 "$(pidofproc $WD_PATHNAME)" > /dev/null 2>&1
    RETVAL=$?
    log_end_msg $RETVAL
}

# Function that stops the watchdog
do_stop_wd () {
    # Stop pglcmd.wd
    echo -n "Stopping $(basename $WD_PATHNAME)"
    # Watchdog does not react to the TERM signal, while he´s sleeping.
    # Therefore send a KILL. The pidfile has to be removed manually then, see below!
    PID_OPT=""
    [ -z "$WD_PID" ] || PID_OPT="-p $WD_PID"
    killproc "$PID_OPT" "$WD_PATHNAME" -KILL

    # Verify that the watchdog is really not running.
    kill -0 "$(pidof $WD_PATHNAME)" > /dev/null 2>&1
    # If old process is not running, remember success and break.
    if [ "$?" -eq 0 ] ; then
        # Process is still running
        RETVAL=1
    else
        rm -f $WD_PID
        RETVAL=0
    fi

    log_end_msg $RETVAL
}

# Function that starts daemon and watchdog
do_start () {
    test_DAEMON
    # Check if daemon is already running
    status_of_proc $DAEMON $NAME > /dev/null 2>&1
    RETVAL=$?
    case "$RETVAL" in
        0)  # Daemon is running
            log_success_msg "$NAME is already running, doing nothing."
            ;;
        3)  # Daemon is not running.
            # Build blocklist if necessary to make sure pglcmd's settings are taken.
            [ -e "$MD5SUM_FILE" ] && set_md5sum && [ "$MD5SUM" = "$(cat $MD5SUM_FILE)" ] || build_blocklist
            # All blocklists in the MASTER_BLOCKLIST_DIR directory, except those which end in "~", are used by pgld.
            set_MASTER_BLOCKLISTS
            # Notify users of possible excess blocklists:
            [ -f "$MASTER_BLOCKLIST" ] && [ -f ${MASTER_BLOCKLIST_DIR}/guarding.p2p ] &&
                echo "WARNING: You are using the old ${MASTER_BLOCKLIST_DIR}/guarding.p2p which has been replaced by the new $MASTER_BLOCKLIST."
            [ -f ${MASTER_BLOCKLIST_DIR}/guarding.p2p.backup ] &&
                echo "WARNING: You are using ${MASTER_BLOCKLIST_DIR}/guarding.p2p.backup. Probably you only want to use the new $MASTER_BLOCKLIST."
            test_IPTABLES_TARGET
            test_REJECT
            test_ACCEPT
            test_IPTABLES_VARS
            test_LOG_SYSLOG
            test_PIDFILE

            # Load kernel modules after checking if they are already loaded / were compiled in the kernel directly.
            # Note 1: I (jre) have not seen documentation how this works. E.g. loading (modprobe) a module does
            #         not give the specified entries in /proc/net. But once pgld was started they are there.
            # Note 2: On a first glance some modules might be loaded conditional on some configuration. I decided
            #         against that to allow for e.g, custom iptables rules.

            # xt_NFQUEUE
            case "$IPTABLES_TARGET" in
                NFQUEUE)
                    ( [ -f /proc/net/ip_tables_targets ] && grep -q NFQUEUE /proc/net/ip_tables_targets ) ||
                        modprobe -q xt_NFQUEUE ||
                        modprobe -q ipt_NFQUEUE || {
                        log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module xt_NFQUEUE, not starting $NAME!"
                        exit $E_XEXTERNAL
                        }
                    ;;
                QUEUE)
                    [ -f /proc/net/ip_queue ] ||
                        modprobe -q ip_queue || {
                        log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module ip_queue, not starting $NAME!"
                        exit $E_XEXTERNAL
                        }
                    ;;
            esac
            # TODO: xt_tcpudp
                # /proc/net/ip_tables_matches:
                # udplite
                # udp
                # tcp
            # TODO?: nfnetlink_queue
            # TODO?: nf_conntrack_ipv4
            # TODO?: iptable_filter
            # xt_mark
            ( [ -f /proc/net/ip_tables_matches ] && grep -q mark /proc/net/ip_tables_matches ) ||
                modprobe -q xt_mark ||
                modprobe -q ipt_mark ||
                if [ "$REJECT" = 1 ] || [ "$ACCEPT" = 1 ] ; then
                    log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module xt_mark, not starting $NAME!"
                    log_failure_msg "Use a kernel with netfilter MARK support or reconfigure $(basename $0)"
                    log_failure_msg "to not use the MARKing feature (options REJECT and ACCEPT)."
                    exit $E_XEXTERNAL
                else
                    log_warning_msg "Warning: Could not load kernel module xt_mark, continuing anyway."
                fi
            # ipt_REJECT
            ( [ -f /proc/net/ip_tables_targets ] && grep -q REJECT /proc/net/ip_tables_targets ) ||
                modprobe -q xt_REJECT ||
                modprobe -q ipt_REJECT ||
                if [ "$REJECT_OUT" = REJECT ] || [ "$REJECT_FWD" = REJECT ] || [ "$REJECT_IN" = REJECT ] ; then
                    log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module ipt_REJECT, not starting $NAME!"
                    log_failure_msg "Use a kernel with netfilter REJECT support or reconfigure $(basename $0)"
                    log_failure_msg "to DROP instead of REJECT blocked packets."
                    exit $E_XEXTERNAL
                else
                    log_warning_msg "Warning: Could not load kernel module ipt_REJECT, continuing anyway."
                fi
            # xt_state
            ( [ -f /proc/net/ip_tables_matches ] && grep -q state /proc/net/ip_tables_matches ) ||
                modprobe -q xt_state ||
                modprobe -q ipt_state ||
                if [ "$IPTABLES_ACTIVATION" = 1 ] ; then
                    log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module xt_state, not starting $NAME!"
                    log_failure_msg "Use a kernel with netfilter STATE support or reconfigure $(basename $0)"
                    log_failure_msg "to check all traffic (not only NEW) traffic (option IPTABLES_ACTIVATION)."
                    exit $E_XEXTERNAL
                else
                    log_warning_msg "Warning: Could not load kernel module xt_state, continuing anyway."
                fi
            # xt_multiport
            ALL_WHITE_PORTS="$WHITE_TCP_IN $WHITE_UDP_IN $WHITE_TCP_OUT $WHITE_UDP_OUT $WHITE_TCP_FWD $WHITE_UDP_FWD"
            ( [ -f /proc/net/ip_tables_matches ] && grep -q multiport /proc/net/ip_tables_matches ) ||
                modprobe -q xt_multiport ||
                modprobe -q ipt_multiport ||
                if [ "$IPTABLES_SETTINGS" = 1 ] && [ -n "$ALL_WHITE_PORTS" ] ; then
                    log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module xt_multiport, not starting $NAME!"
                    log_failure_msg "Use a kernel with netfilter MULTIPORT support or reconfigure $(basename $0)"
                    log_failure_msg "to not whitelist any ports."
                    exit $E_XEXTERNAL
                else
                    log_warning_msg "Warning: Could not load kernel module xt_multiport, continuing anyway."
                fi
            # xt_iprange
            [ -f /proc/net/ip_tables_matches ] && grep -q iprange /proc/net/ip_tables_matches ||
                modprobe -q xt_iprange ||
                modprobe -q ipt_iprange || {
                # If CHAINS is empty/not set, then set it to "all". Replace all with the single names.
                CHAINS=${CHAINS:-all}
                [ "$CHAINS" != all ] || CHAINS="INPUT OUTPUT FORWARD"
                for CHAIN in $CHAINS ; do
                    case $CHAIN in
                    INPUT)
                        ALLOW_FILE="$ALLOW_IN"
                        ;;
                    OUTPUT)
                        ALLOW_FILE="$ALLOW_OUT"
                        ;;
                    FORWARD)
                        ALLOW_FILE="$ALLOW_FWD"
                        ;;
                    *)
                        echo "Unknown CHAIN $CHAIN specified."
                        exit 1
                        ;;
                    esac
                    if [ -n "$ALLOW_FILE" ] && [ -f "$ALLOW_FILE" ] ; then
                        log_failure_msg "Error $E_XEXTERNAL: Could not load kernel module xt_iprange, not starting $NAME!"
                        log_failure_msg "Use a kernel with netfilter IPRANGE support or reconfigure $(basename $0)"
                        log_failure_msg "to not use the allow list $ALLOW_FILE."
                        exit $E_XEXTERNAL
                    fi
                done
                log_warning_msg "Warning: Could not load kernel module xt_iprange, continuing anyway."
                }

            # Assuming that iptables rules are not inserted yet since daemon was not running.
            insert_iptables
            echo -n "Starting $NAME ..."

            # Set the log to syslog option
            if [ "$LOG_SYSLOG" -eq 1 ] ; then
                LOG_SYSLOG_OPT="-s"
            else
                LOG_SYSLOG_OPT=""
            fi

            # Set the log to logfile option
            if [ "$LOG_LOGFILE" -eq 1 ] ; then
                LOG_LOGFILE_OPT="-l $DAEMON_LOG"
            else
                LOG_LOGFILE_OPT=""
            fi


            # Set the options for marking matched packets
            if [ "$REJECT" -eq 1 ] ; then
                REJECT_OPT="-r $REJECT_MARK"
            else
                REJECT_OPT=""
            fi
            # Set the options for marking not matched packets
            if [ "$ACCEPT" -eq 1 ] ; then
                ACCEPT_OPT="-a $ACCEPT_MARK"
            else
                ACCEPT_OPT=""
            fi
            # Set the NFQUEUE number only if NFQUEUE and not QUEUE is used
            case "$IPTABLES_TARGET" in
                NFQUEUE)
                    NFQUEUE_NUMBER_OPT="-q $NFQUEUE_NUMBER"
                    ;;
                QUEUE)
                    NFQUEUE_NUMBER_OPT=""
                    ;;
            esac

            # Set D-Bus
            if [ "$DBUS" -eq 1 ]
            then
                DBUS_OPT="-d"
            else
                DBUS_OPT=""
            fi

            # Set the options the daemon is started with
            DAEMON_OPTS="$LOG_SYSLOG_OPT $LOG_LOGFILE_OPT $DBUS_OPT -p $PIDFILE $NFQUEUE_NUMBER_OPT $REJECT_OPT $ACCEPT_OPT $MASTER_BLOCKLISTS"

            # Test NICE_LEVEL setting.
            [ "$NICE_LEVEL" -ge -20 ] && [ "$NICE_LEVEL" -le 19 ] || {
                log_failure_msg "Error $E_CONFIG: Check the NICE_LEVEL setting."
                exit $E_CONFIG
                }

            # Start daemon
            # eval is needed because blocklist names are "quoted" (in order to allow spaces in the name).
            eval start_daemon -n $NICE_LEVEL -p $PIDFILE $DAEMON $DAEMON_OPTS
            RETVAL=$?
            log_end_msg $RETVAL
            if [ "$RETVAL" = 0 ] ; then
                if [ "$WD" = 1 ] ; then
                    # Start pglcmd.wd.
                    do_start_wd
                fi
            else
                # Remove iptables again, since starting failed.
                # Save the retval (although currently delete_iptables doesn't use this variable).
                SAVE_RETVAL=$RETVAL
                delete_iptables
                RETVAL=$SAVE_RETVAL
            fi
            ;;
        # Problematic daemon status. Be verbose and exit!
        *)
            echo "Problematic daemon status: $RETVAL"
            status_of_proc $DAEMON $NAME
            exit $?
            ;;
    esac
}

# Function that stops daemon (but not watchdog)
do_stop () {
    # STATS_MAILTO is set to empty value by init to prevent email_stats on stop
    # during system halt.
    email_stats
    # Remove iptables rules/chains
    delete_iptables
    # As per LSB don't test if daemon is installed on stop!
    echo -n "Stopping $NAME ..."
    PID_OPT=""
    [ -z "$PIDFILE" ] || PID_OPT="-p $PIDFILE"
    killproc "$PID_OPT" "$DAEMON"

    # Verify that the daemon is really not running. This may take some
    # time, even after the killproc ended successfully.
    # Normally killproc should take care of this.
    # Otherwise restarting pgld fails, because it was restarted too early.
    # This also fixes broken lsb init-functions (e.g. Ubuntu hardy), that give
    # the wrong exit code.
    COUNT=0
    # Wait up to 20 seconds
    while [ "$COUNT" -lt 20 ] ; do
        # Verify that the daemon is really not running.
        kill -0 "$(pidof $DAEMON)" > /dev/null 2>&1
        # If old process is not running, remember success and break.
        if [ "$?" -eq 0 ] ; then
            # Process is still running
            RETVAL=1
            sleep 1
            COUNT=$(($COUNT+1))
        else
            rm -f $PIDFILE
            RETVAL=0
            break
        fi
    done
    # If pidfile still exists (stop failed), force pgld to quit.
    [ ! -f "$PIDFILE" ] || ( kill -9 "$(pidof $DAEMON)" && rm -f $PIDFILE )
    RETVAL=$?

    log_end_msg $RETVAL
}

# Function that restarts daemon
do_restart () {
    do_stop
    do_start
}

# Function that rebuilds master blocklist and reloads daemon
do_reload () {
    test_DAEMON
    # Check if daemon is running
    status_of_proc $DAEMON $NAME > /dev/null 2>&1
    RETVAL=$?
    case "$RETVAL" in
        0)  # Daemon is running
            # Build blocklist if necessary to make sure pglcmd's settings are taken.
            # Force to build it, if started with force-update.
            [ "$1" = reload ] &&
            [ -e "$MD5SUM_FILE" ] && set_md5sum && [ "$MD5SUM" = "$(cat $MD5SUM_FILE)" ] || build_blocklist
            # TODO: Note that pgld reloads successfully even if a blocklist is missing.
            # TODO: There should be a check to see whether all blocklists pgld was started with, are available.
            # TODO: Even better would be to check which master blocklists are available and to tell pgld to
            # TODO: use those blocklists. But I think this requires a restart instead of the reload.
            echo -n "Reloading $NAME... "
            kill -s HUP "$(pidofproc $DAEMON)"
            RETVAL=$?
            log_end_msg $RETVAL
            ;;
        3)  # Daemon is not running
            log_success_msg "$NAME is not running, doing nothing."
            RETVAL=0
            ;;
        # Problematic daemon status. Be verbose and exit!
        *)
            echo "Problematic daemon status: $RETVAL"
            status_of_proc $DAEMON $NAME
            exit $?
            ;;
    esac
}

# Read the non-comment|not-empty lines from BLOCKLISTS_LIST.
# Ignore all entries after # (comments).
set_LISTS_URL () {
    if [ -f "$BLOCKLISTS_LIST" ] ; then
        LISTS_URL="$(grep -Ev "^[[:space:]]*#|^[[:space:]]*$" $BLOCKLISTS_LIST | sed "s|#.*$||g")"
        [ $? -eq 0 ] ||
            { log_failure_msg "Error: set_LISTS_URL exited with $?" ; exit 1 ; }
    else
        LISTS_URL=""
    fi
}

# This function depends on LIST:
LIST_URL2LIST_NAME () {
    # Set LIST_URL depending on LIST
    # If you change this function also adapt the function LIST_NAME2LIST_URL in debian/postinst!
    # Since IFS now is standard IFS, separate words (not the complete lines from
    # blocklists.list) are used for LIST.
    # Assuming remote blocklists (supported through wget) for all blocklists in blocklists.list:
    LIST_URL="$(echo $LIST | sed -r "s|http://||" | sed -r "s|https://||" | sed -r "s|ftp://||")"

    # Translate LIST_URL to human readable/debconf LIST_NAME.
    # Several LIST_URL may resolve to the same LIST_NAME, if alternative URLs are known for the same list.
    case "$LIST_URL" in
        list.iblocklist.com/lists/bluetack/level-1 | \
        list.iblocklist.com/?list=bt_level1 | \
        www.bluetack.co.uk/config/level1.gz)
            LIST_NAME="Bluetack_level1"
            ;;
        list.iblocklist.com/lists/bluetack/level-2 | \
        list.iblocklist.com/?list=bt_level2 | \
        www.bluetack.co.uk/config/level2.gz)
            LIST_NAME="Bluetack_level2"
            ;;
        list.iblocklist.com/lists/bluetack/level-3 | \
        list.iblocklist.com/?list=bt_level3 | \
        www.bluetack.co.uk/config/level3.gz)
            LIST_NAME="Bluetack_level3"
            ;;
        list.iblocklist.com/lists/bluetack/edu | \
        list.iblocklist.com/?list=bt_edu | \
        www.bluetack.co.uk/config/edu.gz)
            LIST_NAME="Bluetack_edu"
            ;;
        list.iblocklist.com/lists/bluetack/ads-trackers-and-bad-pr0n | \
        list.iblocklist.com/?list=bt_ads | \
        www.bluetack.co.uk/config/ads-trackers-and-bad-pr0n.gz)
            LIST_NAME="Bluetack_ads"
            ;;
        list.iblocklist.com/lists/bluetack/bogon | \
        list.iblocklist.com/?list=bt_bogon | \
        www.bluetack.co.uk/config/bogon.gz)
            LIST_NAME="Bluetack_bogon"
            ;;
        list.iblocklist.com/lists/bluetack/spyware | \
        list.iblocklist.com/?list=bt_spyware | \
        www.bluetack.co.uk/config/spyware.gz)
            LIST_NAME="Bluetack_spyware"
            ;;
        list.iblocklist.com/lists/bluetack/spider | \
        list.iblocklist.com/?list=bt_spider | \
        www.bluetack.co.uk/config/spider.gz)
            LIST_NAME="Bluetack_spider"
            ;;
        list.iblocklist.com/lists/bluetack/microsoft | \
        list.iblocklist.com/?list=bt_microsoft | \
        www.bluetack.co.uk/config/Microsoft.gz)
            LIST_NAME="Bluetack_Microsoft"
            ;;
        list.iblocklist.com/lists/bluetack/proxy | \
        list.iblocklist.com/?list=bt_proxy | \
        www.bluetack.co.uk/config/proxy.gz)
            LIST_NAME="Bluetack_proxy"
            ;;
        list.iblocklist.com/lists/bluetack/hijacked | \
        list.iblocklist.com/?list=bt_hijacked | \
        www.bluetack.co.uk/config/hijacked.gz)
            LIST_NAME="Bluetack_hijacked"
            ;;
        # Bluetack badpeers (previously known as templist)
        list.iblocklist.com/lists/bluetack/bad-peers | \
        list.iblocklist.com/?list=bt_templist | \
        www.bluetack.co.uk/config/badpeers.gz)
            LIST_NAME="Bluetack_badpeers"
            ;;
        list.iblocklist.com/lists/bluetack/range-test | \
        list.iblocklist.com/?list=bt_rangetest | \
        www.bluetack.co.uk/config/rangetest.gz)
            LIST_NAME="Bluetack_rangetest"
            ;;
        list.iblocklist.com/lists/bluetack/dshield | \
        list.iblocklist.com/?list=bt_dshield | \
        www.bluetack.co.uk/config/dshield.gz)
            LIST_NAME="Bluetack_dshield"
            ;;
        list.iblocklist.com/lists/tbg/primary-threats | \
        list.iblocklist.com/?list=ijfqtofzixtwayqovmxn | \
        tbg.iblocklist.com/Lists/PrimaryThreats.zip)
            LIST_NAME="TBG_Primary_Threats"
            ;;
        list.iblocklist.com/lists/tbg/general-corporate-ranges | \
        list.iblocklist.com/?list=ecqbsykllnadihkdirsh | \
        tbg.iblocklist.com/Lists/GeneralCorporateRanges.zip)
            LIST_NAME="TBG_General_Corporate_Ranges"
            ;;
        list.iblocklist.com/lists/tbg/business-isps | \
        list.iblocklist.com/?list=jcjfaxgyyshvdbceroxf | \
        tbg.iblocklist.com/Lists/BusinessISPs.zip)
            LIST_NAME="TBG_Business_ISPs"
            ;;
        list.iblocklist.com/lists/tbg/educational-institutions | \
        list.iblocklist.com/?list=lljggjrpmefcwqknpalp | \
        tbg.iblocklist.com/Lists/Educational-Institutions.zip)
            LIST_NAME="TBG_Educational_Institutions"
            ;;
        list.iblocklist.com/lists/tbg/search-engines | \
        list.iblocklist.com/?list=pfefqteoxlfzopecdtyw | \
        tbg.iblocklist.com/Lists/SearchEngines.zip)
            LIST_NAME="TBG_Search_Engines"
            ;;
        list.iblocklist.com/lists/tbg/hijacked | \
        list.iblocklist.com/?list=tbnuqfclfkemqivekikv | \
        tbg.iblocklist.com/Lists/Hijacked.zip)
            LIST_NAME="TBG_Hijacked"
            ;;
        list.iblocklist.com/lists/tbg/bogon | \
        list.iblocklist.com/?list=ewqglwibdgjttwttrinl | \
        tbg.iblocklist.com/Lists/Bogon.zip)
            LIST_NAME="TBG_Bogon"
            ;;
        list.iblocklist.com/lists/atma/atma | \
        http://list.iblocklist.com/?list=tzmtqbbsgbtfxainogvm)
            LIST_NAME="atma_atma"
            ;;
        list.iblocklist.com/lists/bluetack/for-non-lan-computers | \
        list.iblocklist.com/?list=jhaoawihmfxgnvmaqffp)
            LIST_NAME="Bluetack_for-non-lan-computers"
            ;;
        list.iblocklist.com/lists/bluetack/forum-spam | \
        list.iblocklist.com/?list=ficutxiwawokxlcyoeye)
            LIST_NAME="Bluetack_forum-spam"
            ;;
        list.iblocklist.com/lists/bluetack/iana-multicast | \
        list.iblocklist.com/?list=pwqnlynprfgtjbgqoizj)
            LIST_NAME="Bluetack_iana-multicast"
            ;;
        list.iblocklist.com/lists/bluetack/iana-private | \
        list.iblocklist.com/?list=cslpybexmxyuacbyuvib)
            LIST_NAME="Bluetack_iana-private"
            ;;
        list.iblocklist.com/lists/bluetack/iana-reserved | \
        list.iblocklist.com/?list=bcoepfyewziejvcqyhqo)
            LIST_NAME="Bluetack_iana-reserved"
            ;;
        list.iblocklist.com/lists/bluetack/web-exploit | \
        list.iblocklist.com/?list=ghlzqtqxnzctvvajwwag)
            LIST_NAME="Bluetack_web-exploit"
            ;;
        list.iblocklist.com/lists/bluetack/webexploit-forumspam | \
        list.iblocklist.com/?list=ficutxiwawokxlcyoeye)
            LIST_NAME="Bluetack_webexploit-forumspam"
            ;;
        list.iblocklist.com/lists/cidr-report/bogon | \
        list.iblocklist.com/?list=cr_bogon)
            LIST_NAME="cidr-report_bogon"
            ;;
        list.iblocklist.com/lists/dchubad/faker | \
        list.iblocklist.com/?list=dcha_faker)
            LIST_NAME="dchubad_faker"
            ;;
        list.iblocklist.com/lists/dchubad/hacker | \
        list.iblocklist.com/?list=dcha_hacker)
            LIST_NAME="dchubad_hacker"
            ;;
        list.iblocklist.com/lists/dchubad/pedophiles | \
        list.iblocklist.com/?list=dcha_pedophiles)
            LIST_NAME="dchubad_pedophiles"
            ;;
        list.iblocklist.com/lists/dchubad/spammer | \
        list.iblocklist.com/?list=dcha_spammer)
            LIST_NAME="dchubad_spammer"
            ;;
        list.iblocklist.com/lists/nexus23/ipfilterx | \
        list.iblocklist.com/?list=nxs23_ipfilterx)
            LIST_NAME="nexus23_ipfilterx"
            ;;
        list.iblocklist.com/lists/peerblock/rapidshare | \
        list.iblocklist.com/?list=zfucwtjkfwkalytktyiw)
            LIST_NAME="peerblock_rapidshare"
            ;;
        list.iblocklist.com/lists/spamhaus/drop | \
        list.iblocklist.com/?list=sh_drop)
            LIST_NAME="spamhaus_drop"
            ;;
        *)
            # Otherwise, use LIST_URL. For file/directory operations problematic letters have to be replaced!
            LIST_NAME="$LIST_URL"
            ;;
    esac
    LIST_NAME_FIX="$(echo $LIST_NAME | sed "s|.*://|_|" | sed "s|/|_|g" | sed "s/?/_/g" | sed "s/ /_/g")"
}

# Get blocklist.
get_blocklist () {
    # Depends on LIST being set.
    [ -n "$LIST" ] || {
        echo "Error $E_BLOCKLIST: get_blocklist: internal error, LIST is not set or BLOCKLISTS_LIST not existant!"
        exit $E_BLOCKLIST
        }
    test_BLOCKLISTS_DIR
    # This function depends on LIST:
    LIST_URL2LIST_NAME

    # Set blocklist directory name.
    BLOCKLIST_DIR="$BLOCKLISTS_DIR/$LIST_NAME_FIX"
    # Gives the name of the blocklist downloaded by wget. Reset the value here
    # and set it later in the script:
    BLOCKLIST_DOWNLOAD=""
    # Gives the name of successfully downloaded files:
    BLOCKLIST_DOWNLOADED="$BLOCKLIST_DIR/downloaded/$LIST_NAME_FIX"
    # BLOCKLIST_DOWNLOADED is extracted to this file
    BLOCKLIST_EXTRACTED="$BLOCKLIST_DIR/extracted/$LIST_NAME_FIX"

    echo -n "Updating $LIST_NAME... "

    # Assuming remote blocklists (supported through wget) for all blocklists in blocklists.list:
    # Create necessary directories if missing:
    [ -d "$BLOCKLIST_DIR/download" ] ||
        mkdir -p "$BLOCKLIST_DIR/download" ||
        { log_failure_msg " Error: mkdir -p exited with $?" ; exit 1 ; }

    cd "$BLOCKLIST_DIR/download" ||
        { log_failure_msg " Error: cd exited with $?" ; exit 1 ; }

    # Create necessary directories if missing:
    [ -d "$(dirname $BLOCKLIST_DOWNLOADED)" ] ||
        mkdir -p "$(dirname $BLOCKLIST_DOWNLOADED)" ||
        { log_failure_msg "Error: mkdir -p exited with $?" ; exit 1 ; }

    # Download blocklists with timestamping. If this fails remove
    # the old blocklist (which might be a corrupted file)
    # and try again without timestamping:
    test_external wget || exit $E_XEXTERNAL
    # If 7z is not available, change user agent to pglcmd_x7z,
    # so that iblocklist.com knows we are not capable of 7z.
    test_external 7zr > /dev/null 2>&1 ||
        test_external 7za > /dev/null 2>&1 ||
        test_external 7z > /dev/null 2>&1 ||
        test_external p7zip > /dev/null 2>&1 ||
        WGET_OPTS="$(echo $WGET_OPTS | \
            sed "s|--user-agent=${CMD_NAME}/${VERSION}|--user-agent=${CMD_NAME}_x7z/${VERSION}|")"
    $WGET_OPTS -N "$LIST_URL"
    WGET_RET=$?
    case "$WGET_RET" in
        0)
            ;;
        403)
            echo -n "... Access denied!"
            rm -Rf $BLOCKLIST_DIR/download/* ||
                { log_failure_msg " Error: rm exited with $?" ; exit 1; }
            ;;
        *)
            echo -n "... failed!"
            rm -Rf $BLOCKLIST_DIR/download/* ||
                { log_failure_msg " Error: rm exited with $?" ; exit 1; }
            echo -n " Trying without timestamping ..."
            $WGET_OPTS "$LIST_URL"
            WGET_RET=$?
            ;;
    esac

    # Get the name of the downloaded blocklist: BLOCKLIST_DOWNLOAD
    # Take the newest file, in case there are several files in the folder.
    # There may be several files from different URLs for the same LIST_NAME
    # If the directory is empty the variable will stay empty, too.
    ls $BLOCKLIST_DIR/download/* > /dev/null 2>&1 &&
        BLOCKLIST_DOWNLOAD="$BLOCKLIST_DIR/download/$(ls -1t $BLOCKLIST_DIR/download/ | head -n 1)"

    # Download was not successful, access forbidden
    if [ "$WGET_RET" -eq 403 ] ; then
        if [ -f "$BLOCKLIST_DOWNLOADED" ] ; then
            echo " forbidden! Using old blocklist."
            UPDATE_403="$UPDATE_403 $UPDATE_403 (last modified: $(stat --format=%y $BLOCKLIST_DOWNLOADED | head -c 16));"
        else
            log_failure_msg " Error $E_BLOCKLIST: $LIST_NAME access forbidden. Aborting!"
            log_failure_msg "Check your entry $LIST_URL in $BLOCKLISTS_LIST."
            log_failure_msg "To fix this manually download $LIST_URL and save it as $BLOCKLIST_DOWNLOADED"
            exit $E_BLOCKLIST
        fi
    # Download was not successful
    elif [ "$WGET_RET" -ne 0 ] ; then
        if [ -f "$BLOCKLIST_DOWNLOADED" ] ; then
            echo " failed! Using old blocklist."
            UPDATE_FAIL="$UPDATE_FAIL $LIST_NAME (last modified: $(stat --format=%y $BLOCKLIST_DOWNLOADED | head -c 16));"
        else
            log_failure_msg " Error $E_BLOCKLIST: $LIST_NAME not available. Aborting!"
            log_failure_msg "To fix this manually download $LIST_URL and save it as $BLOCKLIST_DOWNLOADED"
            exit $E_BLOCKLIST
        fi
    # Download was successful ($WGET_RET = 0):
    # This should not happen, just for debugging:
    elif [ -z "$BLOCKLIST_DOWNLOAD" ] ; then
        log_failure_msg " Error: $LIST_URL was downloaded successfully but BLOCKLIST_DOWNLOAD is empty! Strange, aborting!"
        exit 1
    # This should not happen, just for debugging:
    elif [ ! -f "$BLOCKLIST_DOWNLOAD" ] ; then
        log_failure_msg " Error: $LIST_URL was downloaded successfully but $BLOCKLIST_DOWNLOAD doesn't exist! Strange, aborting!"
        exit 1
    # Download was successful, old blocklist is not available or older than the new one:
    elif ( [ ! -f "$BLOCKLIST_DOWNLOADED" ] || [ "$BLOCKLIST_DOWNLOAD" -nt "$BLOCKLIST_DOWNLOADED" ] ) ; then
        cp -f --preserve=timestamps $BLOCKLIST_DOWNLOAD $BLOCKLIST_DOWNLOADED &&
            echo "done." ||
            { log_failure_msg " Error: cp exited with $?"; exit 1; }
        [ -f "$BLOCKLIST_DOWNLOADED" ] &&
            UPDATE_SUCCESS="$UPDATE_SUCCESS $LIST_NAME (last modified: $(stat --format=%y $BLOCKLIST_DOWNLOADED | head -c 16));" ||
            { log_failure_msg " Error: $LIST_URL exists, but $BLOCKLIST_DOWNLOADED doesn't exist! Strange, aborting!" ; exit 1 ; }
    # Download was successful, blocklist is not newer than the old one:
    else
        echo ". No update available."
        [ -f "$BLOCKLIST_DOWNLOADED" ] &&
            UPDATE_SUCCESS_NA="$UPDATE_SUCCESS_NA $LIST_NAME (last modified: $(stat --format=%y $BLOCKLIST_DOWNLOADED | head -c 16));" ||
            { log_failure_msg " Error: $LIST_URL exists, but $BLOCKLIST_DOWNLOADED doesn't exist! Strange, aborting!" ; exit 1 ; }
    fi

    # Unpack the lists
    echo -n "Extracting $LIST_NAME, "

    # Create necessary directories if missing:
    [ -d "$(dirname $BLOCKLIST_EXTRACTED)" ] ||
        mkdir -p "$(dirname $BLOCKLIST_EXTRACTED)" ||
        { log_failure_msg " Error: mkdir -p exited with $?" ; exit 1 ; }

    # This should not happen, just for debugging:
    [ -f "$BLOCKLIST_DOWNLOADED" ] || { \
        log_failure_msg " D'oh, why does $BLOCKLIST_DOWNLOADED not exist? Strange, aborting!" ; exit 1 ; }

    # General: To analyze the file header check
    # http://mark0.net/hexdump.html and get a list of TrID file type / file
    # extension definitions from http://mark0.net/soft-trid-deflist.html
    #
    # Using bytes with hexadecimal value HH:
    # $'\xHH' is a bashism.
    # "$(printf '\xHH')" doesn't work at least for the dash builtin printf, so
    # use: "$(/usr/bin/printf '\xHH')"

    # Read the first six (length of the 7z header) bytes of the packed
    # blocklist:
    case "$(head -c 6 $BLOCKLIST_DOWNLOADED)" in
        # 7z packed file
        "$(/usr/bin/printf '\x37\x7A\xBC\xAF\x27\x1C')")
            echo -n "detected 7z... "
            { test_external 7zr && EXTRACT_CMD='7zr x "$BLOCKLIST_DOWNLOADED" -so > "${BLOCKLIST_EXTRACTED}.tmp" 2>/dev/null' ; } ||
            { test_external 7za && EXTRACT_CMD='7za x "$BLOCKLIST_DOWNLOADED" -so > "${BLOCKLIST_EXTRACTED}.tmp" 2>/dev/null' ; } ||
            { test_external 7z && EXTRACT_CMD='7z x "$BLOCKLIST_DOWNLOADED" -so > "${BLOCKLIST_EXTRACTED}.tmp" 2>/dev/null' ; } ||
            { test_external p7zip && EXTRACT_CMD="p7zip -d < $BLOCKLIST_DOWNLOADED > ${BLOCKLIST_EXTRACTED}.tmp" ; } ||
                exit $E_XEXTERNAL
            eval $EXTRACT_CMD || {
                log_failure_msg "Error $E_BLOCKLIST: Failed to extract $LIST_NAME."
                log_failure_msg "Removing $BLOCKLIST_DOWNLOADED."
                log_failure_msg "Check your configuration in $BLOCKLISTS_LIST and try a new \"$(basename $0) update\"."
                rm "$BLOCKLIST_DOWNLOADED" ||
                    { log_failure_msg "Error: rm exited with $?" ; exit 1 ; }
                exit $E_BLOCKLIST
                }
            ;;
        # gz packed file
        "$(/usr/bin/printf '\x1F\x8B\x08')"*)
            echo -n "detected gz... "
            zcat "$BLOCKLIST_DOWNLOADED" > "${BLOCKLIST_EXTRACTED}.tmp" || {
                log_failure_msg "Error $E_BLOCKLIST: Failed to extract $LIST_NAME."
                log_failure_msg "Removing $BLOCKLIST_DOWNLOADED."
                log_failure_msg "Check your configuration in $BLOCKLISTS_LIST and try a new \"$(basename $0) update\"."
                rm "$BLOCKLIST_DOWNLOADED" ||
                    { log_failure_msg "Error: rm exited with $?" ; exit 1 ; }
                exit $E_BLOCKLIST
                }
            ;;
        # zip packed file
        "$(/usr/bin/printf '\x50\x4B\x03\x04')"*)
            echo -n "detected zip... "
            test_external unzip || exit $E_XEXTERNAL
            unzip -p "$BLOCKLIST_DOWNLOADED" > "${BLOCKLIST_EXTRACTED}.tmp" || {
                log_failure_msg "Error $E_BLOCKLIST: Failed to extract $LIST_NAME."
                log_failure_msg "Removing $BLOCKLIST_DOWNLOADED."
                log_failure_msg "Check your configuration in $BLOCKLISTS_LIST and try a new \"$(basename $0) update\"."
                rm "$BLOCKLIST_DOWNLOADED" ||
                    { log_failure_msg "Error: rm exited with $?" ; exit 1 ; }
                exit $E_BLOCKLIST
                }
            ;;
        # Assuming non-packed otherwise:
        *)
            echo -n "not packed... "
            ln -fs $BLOCKLIST_DOWNLOADED ${BLOCKLIST_EXTRACTED}.tmp ||
                { log_failure_msg " Error: ln exited with $?"; exit 1; }
            ;;
    esac
    # Count the lines in the list
    LIST_LINES="$( wc -l ${BLOCKLIST_EXTRACTED}.tmp | sed "s|${BLOCKLIST_EXTRACTED}.tmp||")"
    if [ "$LIST_LINES" -gt 0 ] ; then
        mv -f "${BLOCKLIST_EXTRACTED}.tmp" "${BLOCKLIST_EXTRACTED}" ||
            { log_failure_msg "Error: mv exited with $?" ; exit 1 ; }
        echo "done."
    else
        # TODO: Remove list from e.g. UPDATE_SUCCESS
        log_warning_msg "${BLOCKLIST_EXTRACTED}.tmp is empty!"
        log_warning_msg "wc -l: $(wc -l ${BLOCKLIST_EXTRACTED}.tmp)"
        if [ -f "$BLOCKLIST_EXTRACTED" ] ; then
            log_warning_msg "Keeping old $BLOCKLIST_EXTRACTED."
            UPDATE_FAIL="$UPDATE_FAIL $LIST_NAME (new list was empty, keeping old, last modified: $(stat --format=%y $BLOCKLIST_DOWNLOADED | head -c 16));"
        else
            touch $BLOCKLIST_EXTRACTED
            UPDATE_FAIL="$UPDATE_FAIL $LIST_NAME (new list was empty, no old list available! Ignoring ...);"
        fi
    fi
    # Add a newline at the end of the blocklist to fix broken lists:
    echo "" >> $BLOCKLIST_EXTRACTED
}

# Function that updates blocklists and reloads daemon
update_blocklists () {
    # Remove the old MD5SUM file now, so that if anything goes wrong it's clear we have to rebuild the blocklist:
    [ -e "$MD5SUM_FILE" ] && { rm "$MD5SUM_FILE" || { log_failure_msg " Error: rm exited with $?" ; exit 1; } ; }

    UPDATE_FAIL=""          # Lists failed blocklist updates
    UPDATE_403=""           # Lists failed blocklist updates with "access forbidden"
    UPDATE_SUCCESS=""       # Lists successful blocklist updates
    UPDATE_SUCCESS_NA=""    # Lists blocklist where no update was available

    # Read the non-comment|not-empty lines from BLOCKLISTS_LIST.
    # Ignore all entries after # (comments).
    # LISTS_URL are all blocklists that are configured to be handled automatically.
    set_LISTS_URL

    # Only do the automatic updating, if any blocklist is configured to be handled automatically.
    if [ -n "$LISTS_URL" ] ; then
        echo "Updating blocklists ..."
        test_net

        for LIST in $LISTS_URL ; do
            get_blocklist
        done

        echo "Blocklists updated."
    else
        echo "Automatic blocklist management disabled."
    fi
}

# Function that builds the blocklist
build_blocklist () {
    # Move master blocklist to backup position. This way it is also removed,
    # in case the configuartion changed in that way, that no blocklists are
    # configured for the automatic blocklist management.
    [ -f "$MASTER_BLOCKLIST" ] &&
        mv $MASTER_BLOCKLIST ${MASTER_BLOCKLIST}~

    # Read the non-comment|not-empty lines from BLOCKLISTS_LIST.
    # Ignore all entries after # (comments).
    # LISTS_URL are all blocklists that are configured to be handled automatically.
    set_LISTS_URL

    # Only build a master blocklist, if any blocklist is configured to be handled automatically.
    if [ -n "$LISTS_URL" ] ; then
        test_BLOCKLISTS_DIR
        test_DAEMON
        [ -d "$MASTER_BLOCKLIST_DIR" ] || {
            echo -n "Creating missing directory $MASTER_BLOCKLIST_DIR ..."
            mkdir -p "$MASTER_BLOCKLIST_DIR" && echo "."
            } || {
            log_failure_msg "Error $E_XCD: Missing directory $MASTER_BLOCKLIST_DIR."
            log_failure_msg "Check the $MASTER_BLOCKLIST_DIR setting."
            exit $E_XCD
        }

        echo "Building blocklist... "

        BLOCKLISTSCAT=""

        # Prepare removing lines from the blocklist:
        # replace in IP_REMOVE all semicolons with pipe character
        SINGLE_REMOVE="$(echo $IP_REMOVE | sed "s/;/|/g")"

        # Remove the old MD5SUM file now, so that if anything goes wrong,
        # it's clear we have to rebuild the blocklist:
        [ -e "$MD5SUM_FILE" ] &&
            { rm "$MD5SUM_FILE" ||
            { log_failure_msg " Error: rm exited with $?" ; exit 1; } ; }

        for LIST in $LISTS_URL ; do
            # This function depends on LIST:
            LIST_URL2LIST_NAME

            # Set name of the extracted blocklist.
            BLOCKLIST_EXTRACTED="$BLOCKLISTS_DIR/$LIST_NAME_FIX/extracted/$LIST_NAME_FIX"

            # Test if list is available:
            [ -f "$BLOCKLIST_EXTRACTED" ] ||
                get_blocklist || {
                log_failure_msg "Error $E_BLOCKLIST: $LIST_NAME not available."
                log_failure_msg "Check the entry $LIST"
                log_failure_msg "in $BLOCKLISTS_LIST. Aborting!"
                exit $E_BLOCKLIST
                }

            # Log which lines will be removed later
            if [ -n "$IP_REMOVE" ] ; then
                echo "Removing the following lines from $LIST_NAME:"
                grep -Ei "$SINGLE_REMOVE" "$BLOCKLIST_EXTRACTED" | sort
            fi

            # Remember all used lists
            BLOCKLISTSCAT="$BLOCKLISTSCAT $BLOCKLIST_EXTRACTED"
        done

        if [ -z "$BLOCKLISTSCAT" ] ; then
            log_failure_msg "Error $E_BLOCKLIST: Strange! There are no blocklists available, although some are configured and seemed to be available! Aborting."
            exit $E_BLOCKLIST
        else
            # Tells whether blocklist was built successfully
            BUILT=0

            # Build blocklist and remove some lines from the blocklists
            if [ -n "$IP_REMOVE" ] ; then
                # Cat together all single blocklists
                cat --squeeze-blank $BLOCKLISTSCAT | \
                # Ignore comment lines
                grep -Ev "^[[:space:]]*#" | \
                # Remove lines from IP_REMOVE (case-insensitive)
                grep -Eiv "$SINGLE_REMOVE" | \
                # Replace repeated whitespace with a single occurence
                tr -s [:space:] | \
                # Delete everything complimentary to the following characters/regex
                # alphanumeric
                # space
                # :\*.-,[]
                # newline (return gets removed, so CR+LF gets LF)
                tr -cd '[:alnum:][:space:]:\\\*\.\-,[]\n' | \
                # Only keep the last occurence of :
                sed 's/.*:/&|/' | tr -d : | tr "\|" ":" | \
                # Premerge the blocklist
                $DAEMON -m > $MASTER_BLOCKLIST && BUILT=1
            # Build blocklist without removing some lines from the blocklists
            else
                # Cat together all single blocklists
                cat --squeeze-blank $BLOCKLISTSCAT | \
                # Ignore comment lines
                grep -Ev "^[[:space:]]*#" | \
                # Replace repeated whitespace with a single occurence
                tr -s [:space:] | \
                # Delete everything complimentary to the following characters/regex
                # alphanumeric
                # space
                # :\*.-,[]
                # newline (return gets removed, so CR+LF gets LF)
                tr -cd '[:alnum:][:space:]:\\\*\.\-,[]\n' | \
                # Only keep the last occurence of :
                sed 's/.*:/&|/' | tr -d : | tr "\|" ":" | \
                # Premerge the blocklist, pgld's information is sent to STDERR
                # and therefore ends in pglcmd.log
                $DAEMON -m > $MASTER_BLOCKLIST && BUILT=1
            fi

            [ "$BUILT" -eq 1 ] &&
                log_end_msg 0 ||
                    {
                        log_failure_msg "Error: build_blocklist failed."
                        if [ -f ${MASTER_BLOCKLIST}~ ] ; then
                            echo -n "Restoring $MASTER_BLOCKLIST ..."
                            mv ${MASTER_BLOCKLIST}~ $MASTER_BLOCKLIST ||
                                { log_failure_msg " Error: mv exited with $?" ; exit 1 ; }
                            log_end_msg 0
                        else
                            exit $E_BLOCKLIST
                        fi
                    }
        fi
    else
        echo "No blocklists are configured in $BLOCKLISTS_LIST."
    fi
    # Save configuration settings on which this blocklist bases:
    set_md5sum
    echo "$MD5SUM" > "$MD5SUM_FILE"
}

# Function that tests if IPs get blocked
test_ipblocking () {
    # First check some preconditions for the test:
    test_DAEMON
    test_REJECT

    # All blocklists in the MASTER_BLOCKLIST_DIR directory, except those which end in "~", are used by pgld.
    set_MASTER_BLOCKLISTS
    # Use the last master blocklist as test list.
    TEST_LIST="$(echo $MASTER_BLOCKLISTS | sed "s|.*\(\".*\"\)|\1|")"
    # eval is needed because blocklist names are "quoted" (in order to allow spaces in the name).
    eval [ -f "$TEST_LIST" ] || {
        log_failure_msg " Error $E_BLOCKLIST: $TEST_LIST not available."
        exit $E_BLOCKLIST
        }

    # Detect the logfile, where hits are logged.
    if [ "$LOG_LOGFILE" -eq 1 ] ; then
        TEST_LOG="$DAEMON_LOG"
    elif [ "$LOG_SYSLOG" -eq 1 ] ; then
        TEST_LOG="/var/log/syslog"
    else
        echo "Error: $NAME has to be started with either LOG_SYSLOG=\"1\" or LOG_LOGFILE=\"1\" for \"test\" to work."
        exit $E_CONFIG
    fi
    # If logfile does not exist (for whatever reasons), just create a plain one.
    # If it is missing this does not necessarily mean that the daemon is not running.
    [ -f "$TEST_LOG" ] || touch $TEST_LOG

    echo "Testing $DESC:"
    # Check if daemon is running
    status_of_proc $DAEMON $NAME > /dev/null 2>&1
    RETVAL=$?
    case "$RETVAL" in
        0)    # Daemon is running
            true
            ;;
        3)    # Daemon is not running
            status_of_proc $DAEMON $NAME
            exit $?
            ;;
        *)    # Problematic daemon status. Be verbose and exit!
            echo "Problematic daemon status: $RETVAL"
            status_of_proc $DAEMON $NAME
            exit $?
            ;;
    esac

    # Pick TEST_IP. Assume blocklist in text (not binary) format.
    TESTLINE="$(expr $$ % 100 + 10)"

    # Pick the last IP address from a random line in BLOCKLIST file (earlier IPs often result in problems with ping)
    # Remove the leading zeros in the IPs.
    # eval is needed because blocklist names are "quoted" (in order to allow spaces in the name).
    TEST_IP="$(eval head -n$TESTLINE $TEST_LIST | grep -Eo "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" | tail -n1 )"
    echo "CAUTION: This is just a simple test to check if $DESC blocks"
    echo "outgoing connections. For this, an IP from the blocklist will be pinged. Then "
    echo "the test checks if this IP appears in $TEST_LOG."
    if [ "$REJECT" -eq 1 ] ; then
        echo "$NAME marks packets to be blocked. This means you have to make sure that the"
        echo "marked packets are also blocked later (with appropriate iptables rules). If you"
        echo "are using the default configuration and $NAME is started after other firewalls"
        echo "this will be the case."
    fi
    echo "This test does not check if you have sane iptables rules or if your complete"
    echo "blocklist is in the correct format. Therefore success doesn't imply that"
    echo "everything is working as you expect it."
    echo ""
    echo "Also have a look at \"$(basename $0) status\"."
    echo ""

    echo "Trying to ping $TEST_IP from $MASTER_BLOCKLIST ..."
    LOG_LENGTH="$(wc -l ${TEST_LOG} | awk '{ print $1 }')"    # remember log length before test
    ping -c1 -W2 $TEST_IP > /dev/null 2>&1
    RETVAL_PING=$? # the ping exit code
    # The ping exit status is 0 if ping succeeds and 1 if ping does not receive any reply packets.
    # On other error it exits with code 2.

    # Wait a second to give the daemon time to log the current block
    sleep 1
    LOG_LENGTH_NEW="$(wc -l ${TEST_LOG} | awk '{ print $1 }')" # new log length

    if [ "$LOG_LENGTH" -ne "$LOG_LENGTH_NEW" ] ; then    # log length changed
        tail -n$(($LOG_LENGTH_NEW-$LOG_LENGTH)) $TEST_LOG | \
            grep -q $TEST_IP
        RETVAL=$? # the grep exit status
        # The grep exit status is 0 if selected lines are found and 1 otherwise.
        # If an error occurred the grep exit status is 2.
    else
        RETVAL=1
    fi

    if [ "$RETVAL" -eq 0 ] ; then    # IP in logfile
        if [ "$RETVAL_PING" -eq 1 ] ; then    # No reply to ping
            if [ "$REJECT" -eq 1 ] ; then
                echo "$NAME marked the IP to be blocked and the IP did not answer."
                echo "Test succeeded."
            else
                echo "$NAME blocked the IP. Test succeeded."
            fi
        elif [ "$RETVAL_PING" -eq 0 ] ; then    # Reply to ping
            if [ "$REJECT" -eq 1 ] ; then
                echo "$NAME blocked the IP, but ping got an answer or failed."
                echo "Check the iptables settings and make sure that \"marked block\" packets really"
                echo "get blocked."
                RETVAL=2
            else    # REJECT is 0
                echo "$NAME blocked the IP, but ping got an answer or failed - strange."
                RETVAL=2
            fi
        else
            echo "Some error occured with ping, no test result."
            RETVAL=2
        fi
    elif [ "$RETVAL" -eq 1 ] ; then    # IP not in logfile
        if [ "$REJECT" -eq 1 ] ; then
            echo "$NAME did not mark the IP to be blocked."
        else    # REJECT is 0
            echo "$NAME did not block the IP."
        fi
        if [ "$RETVAL_PING" -eq 0 ] ; then    # Reply to ping
            echo "$TEST_IP answered. Test failed."
        elif [ "$RETVAL_PING" -eq 1 ] ; then    # No reply to ping
            echo "$TEST_IP did not answer the ping."
            echo ""
            echo "No clear test result! Trying \"traceroute -n -m 2 $TEST_IP\" now:"
            TRACE_LOG="${TMPDIR}/$(basename $0).test.log"
            traceroute -n -m 2 $TEST_IP > $TRACE_LOG 2>&1
            RETVAL_TRACEROUTE=$?    # the traceroute exit status
            cat $TRACE_LOG
            echo ""
            if [ "$RETVAL_TRACEROUTE" -eq 1 ] && grep -q "send: Operation not permitted" $TRACE_LOG ; then
                echo "Probably the traceroute packet was blocked by another iptables rule on your"
                echo "machine. Everything might be ok."
                RETVAL=0
            elif [ "$RETVAL_TRACEROUTE" -eq 0 ] && [ "$(wc -l $TRACE_LOG | awk '{ print $1 }')" -eq 2 ] ; then
                # Wait a second to give the daemon time to log the current block
                sleep 1
                LOG_LENGTH_NEW="$(wc -l ${TEST_LOG} | awk '{ print $1 }')" # new log length
                if [ "$LOG_LENGTH" -ne "$LOG_LENGTH_NEW" ] ; then    # log length changed
                    tail -n$(($LOG_LENGTH_NEW-$LOG_LENGTH)) $TEST_LOG | \
                        grep -q $TEST_IP
                    RETVAL=$? # the grep exit status
                    # The grep exit status is 0 if selected lines are found and 1 otherwise.
                    # If an error occurred the grep exit status is 2.
                    if [ "$RETVAL" -eq 0 ] ; then
                        echo "Now the packet was blocked by pglcmd. Everything might be ok."
                        RETVAL=0
                    fi
                else
                    echo "The packet did not leave your machine, but wasn't blocked either. Confusing."
                    echo "Traceroute return code was $RETVAL_TRACEROUTE."
                fi
            elif [ "$RETVAL_TRACEROUTE" -eq 0 ] && [ "$(wc -l $TRACE_LOG | awk '{ print $1 }')" -eq 3 ] ; then
                echo "The traceroute packet was not blocked on your machine. There is a problem!"
            else
                echo "Probably $TEST_IP is down/doesn't answer to pings."
                echo "This still means that $NAME is not working!"
            fi
        else
            echo "Some error occured with ping, no test result."
            RETVAL=2
        fi
    else    # grep error
        echo "Some error occured with grep, no test result."
        RETVAL=2
    fi
    return $RETVAL
}

dump_stats () {
    if [ "$LOG_LOGFILE" = 1 ] ; then
        CURLINE="$(wc -l $DAEMON_LOG | awk '{print$1}')"
        kill -s USR2 "$(pidofproc $DAEMON)"
        sleep 5
        tail -n+$(($CURLINE + 1)) $DAEMON_LOG | grep STATS:
    elif [ "$LOG_SYSLOG" = 1 ] ; then
        CURLINE=$(grep pgld: /var/log/syslog | wc -l | awk '{print$1}')
        kill -s USR2 "$(pidofproc $DAEMON)"
        sleep 5
        grep pgld: /var/log/syslog | tail -n+$(($CURLINE + 1)) | grep STATS:
    else
        echo "Logging to logfile or syslog must be enabled to dump stats."
    fi
}

reset_stats () {
    if [ "$LOG_LOGFILE" = 1 ] ; then
        CURLINE="$(wc -l $DAEMON_LOG | awk '{print$1}')"
        kill -s USR1 "$(pidofproc $DAEMON)"
        sleep 5
        tail -n+$(($CURLINE + 1)) $DAEMON_LOG | grep STATS:
    elif [ "$LOG_SYSLOG" = 1 ] ; then
        CURLINE="$(grep pgld: /var/log/syslog | wc -l | awk '{print$1}')"
        kill -s USR1 "$(pidofproc $DAEMON)"
        sleep 5
        grep pgld: /var/log/syslog | tail -n+$(($CURLINE + 1)) | grep STATS:
    else
        echo "Logging to logfile or syslog must be enabled to dump stats"
    fi
}

email_stats () {
    # Check if daemon is running, otherwise stats are not available!
    if status_of_proc $DAEMON $NAME > /dev/null 2>&1 ; then
        # Find sendmail
        if [ -x /usr/sbin/sendmail ] ; then
            SENDMAIL="/usr/sbin/sendmail"
        elif [ -x /usr/lib/sendmail ] ; then
            SENDMAIL="/usr/lib/sendmail"
        fi
        SUBJECT="$NAME hit statistics"
        # Check if pgl is configured to send email stats and if sendmail is available
        if [ $STATS_MAILTO ] && [ $SENDMAIL ] ; then
            cat<<EOF | $SENDMAIL -t
To: $STATS_MAILTO
Subject: $SUBJECT

$(reset_stats)

EOF
        fi
    fi
}

search () {
    # Read the non-comment|not-empty lines from BLOCKLISTS_LIST.
    # Ignore all entries after # (comments).
    set_LISTS_URL
    echo "Checking your currently used blocklists for \"$SEARCHPATTERN\" (case-insensitive):"
    for LIST in $LISTS_URL ; do
        # This function depends on LIST:
        LIST_URL2LIST_NAME
        BLOCKLIST="$BLOCKLISTS_DIR/$LIST_NAME_FIX/extracted/$LIST_NAME"
        # Exit immediately with zero status if any match is found
        grep -qEi "$SEARCHPATTERN" "$BLOCKLIST" && {
            echo
            echo "$LIST_NAME ($LIST):"
            grep -Ei "$SEARCHPATTERN" "$BLOCKLIST"
            # Remember that current list contains SEARCHPATTERN
            HITLIST="$HITLIST $LIST"
            }
    done
    echo
    echo "\"$SEARCHPATTERN\" was found in these lists:"
    for LIST in $HITLIST ; do
        # This function depends on LIST:
        LIST_URL2LIST_NAME
        echo "$LIST_NAME ($LIST)"
    done
    echo
    echo "If you don't want to block the above shown ranges, then you may add"
    echo "\"$SEARCHPATTERN\" to IP_REMOVE in $CMD_CONF."
    echo "Or you may remove some of these lists from $BLOCKLISTS_LIST."
}
